##quiet
## vim: set ft=ruby:
=begin

    SBounty by SpiffyJr (spiffyjr@gmail.com)

    Does all bounties except gem, escorts, and bandits. Gems should
    be handled via your loot with stockpiling.

    Feel free to send donations or Gift's of Adventure.

     author: spiffyjr
      email: theman@spiffyjr.me
       name: SpiffyBounty
       tags: bounty
    version: 1.0

=end

$sbounty_debug = false
#$stop_bounty = "small green olive|herald|janissary|construct"
$stop_bounty = "Icemule Trail|Slope|small green olive|fleshbinder bud|fleshsore bulb|green fleshbulb|Pinefar forests|Sleeping Lady"
stopbounty = false

Settings[:locations] = CharSettings[:locations]

CharSettings[:enable_cull]      = CharSettings[:enable_cull].nil? ? true : CharSettings[:enable_cull]
CharSettings[:enable_dangerous] = CharSettings[:enable_dangerous].nil? ? true : CharSettings[:enable_dangerous]
CharSettings[:enable_forage]    = CharSettings[:enable_forage].nil? ? true : CharSettings[:enable_forage]
CharSettings[:enable_loot]      = CharSettings[:enable_loot].nil? ? true : CharSettings[:enable_loot]
CharSettings[:enable_rescue]    = CharSettings[:enable_rescue].nil? ? true : CharSettings[:enable_rescue]
CharSettings[:enable_search]    = CharSettings[:enable_search].nil? ? true : CharSettings[:enable_search]
CharSettings[:enable_bandit]    = CharSettings[:enable_bandit].nil? ? false : CharSettings[:enable_bandit]
CharSettings[:enable_skin]      = CharSettings[:enable_skin].nil? ? true : CharSettings[:enable_skin]
CharSettings[:enable_expedite]  = CharSettings[:enable_expedite].nil? ? true : CharSettings[:enable_expedite]

CharSettings[:enable_hunt_complete] = CharSettings[:enable_hunt_complete].nil? ? true : CharSettings[:enable_hunt_complete]

CharSettings[:pre_search_commands]  ||= ['store all']
CharSettings[:post_search_commands] ||= ['gird']
CharSettings[:forage_retry_delay]   ||= 300
CharSettings[:loot_script]          ||= 'sloot'
CharSettings[:turn_in_percent]      ||= 95

CharSettings[:should_hunt_mind]    ||= 75
CharSettings[:should_hunt_mana]    ||= 0
CharSettings[:should_hunt_spirit]  ||= 7
CharSettings[:hunt_pre_commands]   ||= ['gird']
CharSettings[:should_rest_mind]    ||= 100
CharSettings[:should_rest_mana]    ||= 0
CharSettings[:should_rest_encum]   ||= 20
CharSettings[:should_rest_wounded] ||= StringProc.new 'bleeding? || percenthealth <= 50 || ([Wounds.head, Scars.head].max >= 2) || ([Wounds.nsys, Scars.nsys].max >= 2) || ([Wounds.leftArm, Wounds.leftHand, Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand, Scars.rightArm, Scars.rightHand].max >= 3) || ( ([Wounds.leftArm, Wounds.leftHand, Scars.leftArm, Scars.leftHand].max >= 2) or ([Wounds.rightArm, Wounds.rightHand, Scars.leftArm, Scars.leftHand].max >= 2) )'

CharSettings[:rest_in_commands]    ||= ['go table, si']
CharSettings[:rest_out_commands]   ||= ['stand', 'out']
CharSettings[:rest_pre_commands]   ||= ['store all']
CharSettings[:rest_scripts]        ||= ['useherbs --buy-missing=on', 'sloot sell', 'waggle']
CharSettings[:rest_sleep_interval] ||= 30

CharSettings[:locations] ||= {}

$sbounty_rest        = false
$current_bounty      = "none"
$sbounty_rest_reason = nil
in_rest_area         = false
rest_reason          = nil
hunt_reason          = nil
can_do_bounty_cache  = nil
expedite_left        = true
last_forage_attempt  = 0
last_forage_delay    = 300

if UserVars.lootsack.nil? or UserVars.lootsack.empty?
    echo '** lootsack has not been set, set it with ;set change lootsack [container]'
    exit
end

if CharSettings[:enable_skin] and (UserVars.skinsack.nil? or UserVars.skinsack.empty?)
    echo '** skinsack has not been set, set it with ;set change skinsack [container]'
    exit
end

#lootsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.lootsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
#skinsack = GameObj.inv.find { |i| i.noun =~ /#{UserVars.skinsack}/ } or GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
lootsack = GameObj.inv.find { |i| i.name =~ /#{UserVars.lootsack}/ }
skinsack = GameObj.inv.find { |i| i.name =~ /#{UserVars.skinsack}/ } 

if lootsack.nil?
    echo '** failed to find your lootsack, set it with ;set change lootsack [container]'
    exit
end

if CharSettings[:enable_skin] and skinsack.nil?
    echo '** failed to find your skinsack, set it with ;set change skinsack [container]'
    exit
end

# You have been tasked to recover a peridot-inset pewter ring that an unfortunate citizen lost after being attacked by a storm giant in the Upper Trollfang near Wehnimer's Landing.  The heirloom can be identified by the initials MG engraved upon it.  Hunt down the creature and LOOT the item from its corpse.


bounty_patterns = {
    'none' => '^You are not currently assigned a task\.',

    # help
    'help_bandit'    => 'It appears they have a bandit problem',
    'help_creature'  => 'It appears they have a creature problem they\'d like you to solve\.',
    'help_resident'  => 'It appears that a local resident urgently needs our help in some matter\.',
    'help_heirloom'  => 'It appears they need your help in tracking down some kind of lost heirloom\.',
    'help_gemdealer' => 'The local gem dealer, .*, has an order to fill and wants our help\.',
    'help_herbalist' => 'local herbalist|local healer|local alchemist',
    'help_furrier'   => 'The local furrier',

    # in progress
    'task_bandit'    => '^You have been tasked to suppress bandit activity (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.)',
    'task_escort'    => '^You have made contact with the child',
    'task_dangerous' => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near|between|under) (?:the )?(.*?)(?:\s(?:in|on|near|between|under).*\.|\.)\s+You can',
    'task_provoked'  => 'You have been tasked to hunt down and kill a particularly dangerous (.*) that has established a territory (?:in|on|near|between|under) (?:the )?([\w\'\s-]+)(?:\s(?:in|on|near|between|under).*\.|\.)\s+ You have provoked',
    'task_dealer'    => '^The(?: local)? gem dealer',
    'task_forage'    => 'concoction that requires (?:a|an|some) (.*) found (?:in|on|near|between|under) (?:the )?(.*?)(?: near| between| under|\.).*These samples must be in pristine condition\.\s+You have been tasked to retrieve (\d+)(?: more)? samples?\.',
    'task_cull'      => 'You have been tasked to suppress (.*) activity (?:in|on|near) (?:the )?(.*)\. ',
    'task_search'    => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.).*\.  SEARCH',
    'task_heirloom'  => 'unfortunate citizen lost after being attacked by (?:a|an) (.*) (?:in|on|near|between|under) (?:the )?(.*)\s(?:near|between|under|\.).*LOOT',
    'task_found'     => 'You have located the heirloom',
    'task_skin'      => '^You have been tasked to retrieve (\d+|\w+)s? (.*) of at least .*\.  You can SKIN them off the corpse of (?:a|an) (.*) or ',
    'task_rescue'    => 'A local divinist has had visions of the child fleeing from (?:a|an) (.*) (?:in|on|near|between|under) (?:the )?(.*) (?:near|between|under)',

    # fail
    'fail_child' => 'The child you were tasked to rescue is gone and your task is failed\.',

    # success
    'success'          => '^You have succeeded in your task and can return',
    'success_guard'    => '^You succeeded in your task and should report back to',
    'success_heirloom' => '^You have located the heirloom and should bring it back .*\.$',
}

setup = proc {
    script_name = script.name

    action   = nil
    window   = nil
    notebook = nil

    locations = CharSettings[:locations].dup
    location  = nil

    error = proc { |msg|
        dlg = Gtk::Dialog.new(
            'Error!',
            window,
            Gtk::Dialog::DESTROY_WITH_PARENT,
            [ Gtk::Stock::OK, Gtk::Dialog::RESPONSE_NONE ]
        )
        dlg.resize 200,100
        dlg.signal_connect 'response' do dlg.destroy end
        dlg.vbox.add(Gtk::Label.new(msg))
        dlg.show_all
    }

    widgets = {
        :gui_widgets => {
            # buttons
            :close  => Gtk::Button.new('Close'),
            :create => Gtk::Button.new('Create'),
            :delete => Gtk::Button.new('Delete'),
            :save   => Gtk::Button.new('Save & Close'),

            # combos
            :locations => Gtk::ComboBox.new,

            # entries
            :new_name => Gtk::Entry.new,
        },

        :location_widgets => {
            # check buttons
            :enable_bounty_only      => Gtk::CheckButton.new('Only attack bouny critters'),
            :enable_hunting_rotation => Gtk::CheckButton.new('In hunting rotation'),
            :enable_search_only      => Gtk::CheckButton.new('Only search here (no hunting)'),

            #entries
            :location   => Gtk::Entry.new,
            :skins      => Gtk::Entry.new,
            :targets    => Gtk::Entry.new,
            :room       => Gtk::Entry.new,
            :boundaries => Gtk::Entry.new,
        },

        # check buttons
        :enable_cull      => Gtk::CheckButton.new('Cull critters').set_active(CharSettings[:enable_cull]),
        :enable_dangerous => Gtk::CheckButton.new('Dangerous critter').set_active(CharSettings[:enable_dangerous]),
        :enable_forage    => Gtk::CheckButton.new('Forage herbs').set_active(CharSettings[:enable_forage]),
        :enable_loot      => Gtk::CheckButton.new('Loot heirloom').set_active(CharSettings[:enable_loot]),
        :enable_rescue    => Gtk::CheckButton.new('Rescue child').set_active(CharSettings[:enable_rescue]),
        :enable_search    => Gtk::CheckButton.new('Search heirloom').set_active(CharSettings[:enable_search]),
        :enable_bandit    => Gtk::CheckButton.new('Bandits').set_active(CharSettings[:enable_bandit]),
        :enable_skin      => Gtk::CheckButton.new('Skin critters').set_active(CharSettings[:enable_skin]),
        :enable_expedite  => Gtk::CheckButton.new('Expedite bounties').set_active(CharSettings[:enable_expedite]),

        :enable_hunt_complete => Gtk::CheckButton.new('Hunt until complete?').set_active(CharSettings[:enable_hunt_complete]),

        # entries
        :pre_search_commands  => Gtk::Entry.new.set_text(CharSettings[:pre_search_commands].collect { |a| a.strip }.join(',')),
        :post_search_commands => Gtk::Entry.new.set_text(CharSettings[:post_search_commands].collect { |a| a.strip }.join(',')),
        :forage_retry_delay   => Gtk::Entry.new.set_text(CharSettings[:forage_retry_delay].to_s),
        :loot_script          => Gtk::Entry.new.set_text(CharSettings[:loot_script].to_s),
        :turn_in_percent      => Gtk::Entry.new.set_text(CharSettings[:turn_in_percent].to_s),

        :should_hunt_mind   => Gtk::Entry.new.set_text(CharSettings[:should_hunt_mind].to_s),
        :should_hunt_mana   => Gtk::Entry.new.set_text(CharSettings[:should_hunt_mana].to_s),
        :should_hunt_spirit => Gtk::Entry.new.set_text(CharSettings[:should_hunt_spirit].to_s),

        :hunt_pre_commands => Gtk::Entry.new.set_text(CharSettings[:hunt_pre_commands].collect { |a| a.strip }.join(',')),
        :hunt_commands_a   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_a].collect { |a| a.strip }.join(',')),
        :hunt_commands_b   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_b].collect { |a| a.strip }.join(',')),
        :hunt_commands_c   => Gtk::Entry.new.set_text(CharSettings[:hunt_commands_c].collect { |a| a.strip }.join(',')),

        :should_rest_mana    => Gtk::Entry.new.set_text(CharSettings[:should_rest_mana].to_s),
        :should_rest_mind    => Gtk::Entry.new.set_text(CharSettings[:should_rest_mind].to_s),
        :should_rest_encum   => Gtk::Entry.new.set_text(CharSettings[:should_rest_encum].to_s),
        :should_rest_wounded => Gtk::Entry.new.set_text(CharSettings[:should_rest_wounded]._dump),

        :rest_in_commands  => Gtk::Entry.new.set_text(CharSettings[:rest_in_commands].collect { |a| a.strip }.join(',')),
        :rest_out_commands => Gtk::Entry.new.set_text(CharSettings[:rest_out_commands].collect { |a| a.strip }.join(',')),
        :rest_pre_commands => Gtk::Entry.new.set_text(CharSettings[:rest_pre_commands].collect { |a| a.strip }.join(',')),
        :rest_room         => Gtk::Entry.new.set_text(CharSettings[:rest_room]),
        :rest_scripts      => Gtk::Entry.new.set_text(CharSettings[:rest_scripts].collect { |a| a.strip }.join(','))
    }

    Gtk.queue {
        update_disabled = proc {
            widgets[:location_widgets].each { |key, widget|
                if location.nil?
                    widget.set_sensitive(false)
                else
                    widget.set_sensitive(true)
                end
            }
        }

        populate_locations = proc {
            loop {
                break if not widgets[:gui_widgets][:locations].model.iter_first
                widgets[:gui_widgets][:locations].remove_text(0)
            }

            locations.keys.sort.each { |text|
                widgets[:gui_widgets][:locations].append_text(text)
            }
        }

        save_location = proc {
            widgets[:location_widgets].each { |key, widget|
                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:skins, :targets, :boundaries].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                else
                    value = widget.text.strip
                end

                locations[location][key] = value
            }
        }

        attach_signals = proc {
            widgets[:gui_widgets][:close].signal_connect 'clicked' do action = :close end
            widgets[:gui_widgets][:save].signal_connect 'clicked' do action = :save; save_location.call end

            widgets[:gui_widgets][:create].signal_connect 'clicked' do
                name = widgets[:gui_widgets][:new_name].text.strip

                if name.nil? or name.empty? or name.length < 3
                    error.call 'You need to enter a name!'
                elsif locations.keys.find { |n| n.downcase.strip == name.downcase.strip }
                    error.call 'A location with that name already exists!'
                else
                    locations[name] = {}

                    widgets[:gui_widgets][:new_name].set_text ""

                    populate_locations.call
                    update_disabled.call
                end
            end

            widgets[:gui_widgets][:delete].signal_connect 'clicked' do
                Gtk.queue {
                    if widgets[:gui_widgets][:locations].active == -1
                        error.call 'You do not have a location selected!'
                    else
                        locations.delete(widgets[:gui_widgets][:locations].active_text)
                        widgets[:gui_widgets][:locations].remove_text(widgets[:gui_widgets][:locations].active)

                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.set_active(false)
                            else
                                widget.set_text("")
                            end
                        }
                    end
                }
            end

            widgets[:gui_widgets][:locations].signal_connect 'changed' do
                Gtk.queue {
                    save_location.call

                    location = widgets[:gui_widgets][:locations].active_text

                    if locations[location]
                        widgets[:location_widgets].each { |key, widget|
                            if widget.class == Gtk::CheckButton
                                widget.set_active(!!locations[location][key])
                            elsif [:skins, :targets, :boundaries].include?(key)
                                widget.set_text(locations[location][key].join(','))
                            else
                                widget.set_text(locations[location][key].strip)
                            end
                        }
                    end

                    update_disabled.call
                }
            end
        }

        # main window
        window = Gtk::Window.new
        window.border_width = 5
        window.keep_above = true
        window.resizable = true
        window.resize 500, 300
        window.set_window_position Gtk::Window::POS_CENTER

        # main notebook (tabs)
        notebook = Gtk::Notebook.new
        notebook.show_border = true

        vbox_main = Gtk::VBox.new
        vbox_main.pack_start notebook

        # sbounty options
        vbox = Gtk::VBox.new

        frm = Gtk::Frame.new('Locations').set_border_width(3)
        tbl = Gtk::Table.new(7, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('New name: ')), 0, 1, 0, 1
        tbl.attach widgets[:gui_widgets][:new_name], 1, 3, 0, 1
        tbl.attach widgets[:gui_widgets][:create], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Locations: ')), 0, 1, 1, 2
        tbl.attach widgets[:gui_widgets][:locations], 1, 3, 1, 2
        tbl.attach widgets[:gui_widgets][:delete], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Location: ')), 0, 1, 3, 4
        tbl.attach widgets[:location_widgets][:location], 1, 2, 3, 4
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Skins: ')), 2, 3, 3, 4
        tbl.attach widgets[:location_widgets][:skins], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Targets: ')), 0, 1, 4, 5
        tbl.attach widgets[:location_widgets][:targets], 1, 2, 4, 5

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Room #: ')), 0, 1, 5, 6
        tbl.attach widgets[:location_widgets][:room], 1, 2, 5, 6
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Boundaries: ')), 2, 3, 5, 6
        tbl.attach widgets[:location_widgets][:boundaries], 3, 4, 5, 6

        tbl.attach widgets[:location_widgets][:enable_hunting_rotation], 0, 1, 6, 7
        tbl.attach widgets[:location_widgets][:enable_bounty_only], 1, 2, 6, 7
        tbl.attach widgets[:location_widgets][:enable_search_only], 2, 3, 6, 7

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Bounties').set_border_width(3)
        tbl = Gtk::Table.new(5, 4, true).set_border_width(3)

        tbl.attach widgets[:enable_cull], 0, 1, 0, 1
        tbl.attach widgets[:enable_dangerous], 1, 2, 0, 1
        tbl.attach widgets[:enable_rescue], 2, 3, 0, 1
        tbl.attach widgets[:enable_skin], 3, 4, 0, 1

        tbl.attach widgets[:enable_loot], 0, 1, 1, 2
        tbl.attach widgets[:enable_search], 1, 2, 1, 2
        tbl.attach widgets[:enable_forage], 2, 3, 1, 2
        tbl.attach widgets[:enable_bandit], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('turn in when mind >= ')), 0, 1, 2, 3
        tbl.attach widgets[:turn_in_percent], 1, 2, 2, 3
        tbl.attach widgets[:enable_expedite], 2, 3, 2, 3
        tbl.attach widgets[:enable_hunt_complete], 3, 4, 2, 3

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-search commands: ')), 0, 1, 3, 4
        tbl.attach widgets[:pre_search_commands], 1, 2, 3, 4
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('post-search commands: ')), 2, 3, 3, 4
        tbl.attach widgets[:post_search_commands], 3, 4, 3, 4

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('forage retry delay: ')), 0, 1, 4, 5
        tbl.attach widgets[:forage_retry_delay], 1, 2, 4, 5
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('loot script: ')), 2, 3, 4, 5
        tbl.attach widgets[:loot_script], 3, 4, 4, 5

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Locations / Options')

        # default options
        vbox = Gtk::VBox.new

        frm = Gtk::Frame.new('Should Rest').set_border_width(3)
        tbl = Gtk::Table.new(3, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % >= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_rest_mind], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or mana <= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_rest_mana], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or encumbrance % >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_rest_encum], 1, 2, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('or wounded eval: ')), 0, 1, 2, 3
        tbl.attach widgets[:should_rest_wounded], 1, 4, 2, 3

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Resting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('room #: ')), 0, 1, 0, 1
        tbl.attach widgets[:rest_room], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('pre-rest commands: ')), 2, 3, 0, 1
        tbl.attach widgets[:rest_pre_commands], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('enter commands: ')), 0, 1, 1, 2
        tbl.attach widgets[:rest_in_commands], 1, 2, 1, 2
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('exit commands: ')), 2, 3, 1, 2
        tbl.attach widgets[:rest_out_commands], 3, 4, 1, 2

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('scripts: ')), 0, 1, 2, 3
        tbl.attach widgets[:rest_scripts], 1, 4, 2, 3

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Should Hunt').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('when mind % <= ')), 0, 1, 0, 1
        tbl.attach widgets[:should_hunt_mind], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and mana >= ')), 2, 3, 0, 1
        tbl.attach widgets[:should_hunt_mana], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('and spirit >= ')), 0, 1, 1, 2
        tbl.attach widgets[:should_hunt_spirit], 1, 2, 1, 2

        frm.add(tbl)
        vbox.pack_start(frm)

        frm = Gtk::Frame.new('Hunting').set_border_width(3)
        tbl = Gtk::Table.new(2, 4, true).set_border_width(3)

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Pre-hunt commands: ')), 0, 1, 0, 1
        tbl.attach widgets[:hunt_pre_commands], 1, 2, 0, 1
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (a): ')), 2, 3, 0, 1
        tbl.attach widgets[:hunt_commands_a], 3, 4, 0, 1

        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (b): ')), 0, 1, 1, 2
        tbl.attach widgets[:hunt_commands_b], 1, 2, 1, 2
        tbl.attach Gtk::Alignment.new(1, 0, 0, 1).add(Gtk::Label.new('Commands (c): ')), 2, 3, 1, 2
        tbl.attach widgets[:hunt_commands_c], 3, 4, 1, 2

        frm.add(tbl)
        vbox.pack_start(frm)

        notebook.append_page vbox, Gtk::Label.new('Resting / Hunting')

        # main window widgets
        vbox = Gtk::VBox.new
        vbox.pack_start Gtk::Alignment.new(0, 1, 0, 0), false

        hbox = Gtk::HBox.new
        hbox.add widgets[:gui_widgets][:save]
        hbox.add widgets[:gui_widgets][:close]

        halign = Gtk::Alignment.new 1, 0, 0, 0
        halign.add hbox

        vbox.pack_start halign
        vbox_main.pack_start vbox

        # create the window
        attach_signals.call
        update_disabled.call
        populate_locations.call

        window.add vbox_main
        window.show_all
    }

    before_dying { Gtk.queue { window.destroy unless window.nil? } }

    sleep 0.10 while action.nil?

    case action
        when :save
            CharSettings[:locations] = locations

            widgets.each { |key, widget|
                next if [:location_widgets, :gui_widgets].include?(key)

                if widget.class == Gtk::CheckButton
                    value = widget.active?
                elsif [:pre_search_commands, :post_search_commands, :hunt_pre_commands, :hunt_commands_a, :hunt_commands_b, :hunt_commands_c, :rest_in_commands, :rest_out_commands, :rest_pre_commands, :rest_scripts].include?(key)
                    value = widget.text.strip.split(',').collect { |item| item.strip }
                elsif key == :should_rest_wounded
                    value = StringProc.new widget.text.strip
                else
                    value = widget.text.strip
                end

                CharSettings[key] = value
            }
    end
}

error = proc { |msg|
    echo "** #{msg}"
    exit
}

print = proc { |msg|
    echo "-- #{msg}"
}

clean_skin = proc { |name|
    name.strip.downcase.gsub(/s$/, '').gsub(/teeth/, 'tooth').gsub(/hooves?/, 'hoof')
}

has_skins = proc {
    if bounty? =~ /#{bounty_patterns['task_skin']}/
        count = $1.to_i
        skin  = $2.downcase

        skinsack.contents.find_all { |item| item.name =~ /#{clean_skin.call(skin)}/i }.size >= (count + 5)
    else
        false
    end
}

is_bounty = proc { |types|
    result = []
    types = [types] if types.class != Array

    types.each { |type| result.push(bounty_patterns[type]) if not bounty_patterns[type].nil? }

    !(bounty? =~ /#{result.join('|')}/).nil?
}

get_bounty_location = proc {
    location = target = nil

    # remove search only locations for hunting areas
    locations = CharSettings[:locations].dup
    if is_bounty.call ['task_skin', 'task_heirloom', 'task_dangerous', 'task_cull', 'task_rescue']
        locations.delete_if { |name, data| data[:enable_search_only] }
    end

    if bounty? =~ /#{bounty_patterns['task_skin']}/
        # remember: don't swap the order or the global $ vars are lost!
        target   = $3.strip.downcase
        skin     = clean_skin.call($2)
        location = locations.find { |name, data| GSC.SBOUNTY_CLEAN_TARGETS(data[:targets]).find { |t| t =~ /#{target}/i } and data[:skins].find { |s| skin =~ /#{s.strip.downcase}/i }}
    else
        echo "inside if-else of get_bounty_location- if bounty?" if $sbounty_debug
        bounty_patterns.each { |key,value|
            echo "key: #{key}" if $sbounty_debug
            echo "value: #{value}" if $sbounty_debug
            echo bounty? if $sbounty_debug
            if bounty? =~ /#{value}/i
                target   = $1
                location = $2

                break
            end
        }
        echo "location inside if statement: #{location}" if $sbounty_debug
		location = location.downcase.strip
        echo "location after downcase #{location}" if $sbounty_debug
        location = locations.find { |name, data|
            echo "name: #{name}" if $sbounty_debug
            echo "data: #{data}" if $sbounty_debug
            echo data[:location].strip if $sbounty_debug
            echo data[:location].class if $sbounty_debug
            echo data[:targets] if $sbounty_debug
            echo "target: " + target if target and $sbounty_debug
            temp_location = nil
            temp_target = nil
			temp_target1 = nil
            temp_location = /#{data[:location].strip}/i
            temp_target = GSC.SBOUNTY_CLEAN_TARGETS(data[:targets])
            temp_target.each {|t| 
                echo "t: " + t if $sbounty_debug
                echo "target: " + target if $sbounty_debug and target
                temp_target1 = t if t =~ /#{target}/i
                echo "temp_target: " + temp_target1 if temp_target1 if $sbounty_debug
            }

            echo "temp outside loop " + temp_target1 if temp_target1 if $sbounty_debug
            echo temp_location if temp_location if $sbounty_debug
            true if !temp_location.nil? and !temp_target1.nil?
            #echo "cleaning targets: #{GSC.SBOUNTY_CLEAN_TARGETS(data[:targets])}" if $sbounty_debug
            #echo "location inside locations.find: #{location}" if $sbounty_debug
		}
        echo "location outside locations.find: #{location}" if $sbounty_debug
    end
    echo "location: #{location}" if $sbounty_debug
    if location
        name = location[0].dup
        data = location[1].to_hash.dup

        if target
            targets = data[:targets].dup
            cleaned = GSC.SBOUNTY_CLEAN_TARGETS(data[:targets])
            index   = cleaned.index(cleaned.find { |t| t =~ /#{target}/i })
            target  = targets[index]
            target_old = targets[index]

            if is_bounty.call 'task_provoked' and target !~ /ancient|grizzled/i
                echo "'starting ancient/grizzled target"
                new_target = "(?:ancient|grizzled).*#{cleaned[index].split(' ').last}".downcase
                targets[target.index(target)] = new_target
                target = new_target
            end
        end

        if data[:enable_bounty_only]
            targets = [ target ]
        end

        data[:targets] = targets

        [name, data]
    else
        data[:targets] = target_old if target_old
        print.call 'could not find bounty location'
        nil
    end
}

get_herb_rooms = proc { |location, herb|
    rooms = Room.list.find_all { |room| room.location =~ /^(?:the)?\s*#{location.strip}/i and room.tags.find { |tag| tag =~ /#{herb}/i } }
    rooms = rooms.collect { |r| r.id }

    previous, shortest_distances = Map.dijkstra(CharSettings[:rest_room])
    rooms.delete_if { |room| shortest_distances[room].nil? or shortest_distances[room].to_i > 600 }
}

can_turn_in = proc {
    echo "inside can_turn_in proc" if $sbounty_debug
    echo "Current bounty: #{$current_bounty}" if $sbounty_debug
    echo CharSettings[:turn_in_percent].to_i if $sbounty_debug
    echo checkmind if $sbounty_debug
    CharSettings[:turn_in_percent].nil?
    is_bounty.call ['success', 'success_guard', 'success_heirloom'] and (CharSettings[:turn_in_percent].nil? or (percentmind >= CharSettings[:turn_in_percent].to_i and checkmind !~ /saturated/))
}

can_do_bounty = proc {

     echo "inside can_do_bounty" if $sbounty_debug
    echo "is_bounty.call value: #{is_bounty.call}" if $sbounty_debug
    #echo CharSettings[:enable_rescue] if $sbounty_debug
    echo "Get_bounty_location.call value: #{get_bounty_location.call}" if $sbounty_debug
    if not can_do_bounty_cache.nil?
        ; # intentionally left blank
    elsif is_bounty.call ['success', 'success_heirloom', 'success_guard']
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_bandit'] and CharSettings[:enable_bandit]
        can_do_bounty_cache = true
    elsif ((is_bounty.call 'task_search' and CharSettings[:enable_search] and get_bounty_location.call) or (is_bounty.call 'task_heirloom' and CharSettings[:enable_loot] and get_bounty_location.call))
        can_do_bounty_cache = true
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/ and CharSettings[:enable_forage] and not get_herb_rooms.call($2, $1).empty?
        can_do_bounty_cache = true
    elsif is_bounty.call 'task_skin' and CharSettings[:enable_skin] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call ['task_provoked', 'task_dangerous'] and CharSettings[:enable_dangerous] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif is_bounty.call 'task_cull' and CharSettings[:enable_cull] and get_bounty_location.call
        can_do_bounty_cache = true
    elsif (is_bounty.call 'task_escort' and CharSettings[:enable_rescue]) or (is_bounty.call 'task_rescue' and CharSettings[:enable_rescue] and get_bounty_location.call)
        can_do_bounty_cache = true
    else
        can_do_bounty_cache = false
    end

    echo "can_do_bounty_cache return: #{can_do_bounty_cache}" if $sbounty_debug
    can_do_bounty_cache
}

should_hunt = proc {
    echo "inside should_hunt" if $sbounty_debug
    #exit
    if (not can_do_bounty.call or is_bounty.call ['success', 'success_heirloom', 'success_guard'] or not CharSettings[:enable_hunt_complete]) and percentmind > CharSettings[:should_hunt_mind].to_i
        hunt_reason = 'mind is full'
        should_hunt_return = false
        should_hunt_return = true if (can_do_bounty.call or is_bounty.call ['success', 'success_guard', 'success_heirloom']) and checkmind !~ /saturated/
    elsif not checkmana(CharSettings[:should_hunt_mana].to_i)
        hunt_reason = 'out of mana'
        should_hunt_return = false
    elsif not checkspirit(CharSettings[:should_hunt_spirit].to_i)
        hunt_reason = 'low spirit'
        should_hunt_return = false
    else
        should_hunt_return = true
    end
    echo "Should_hunt proc exiting." if $sbounty_debug
    echo should_hunt_return if $sbounty_debug
    should_hunt_return
}

should_rest = proc {
    echo "Inside should_rest proc" if $sbounty_debug
    if CharSettings[:should_rest_wounded].call
        rest_reason = 'wounded'
        should_rest_return = true
    elsif is_bounty.call 'task_forage' and can_do_bounty.call and Time.now.to_i < last_forage_attempt + last_forage_delay and percentmind >= CharSettings[:should_rest_mind].to_i
        rest_reason = 'mind is full (waiting on foraging cooldown)'
        should_rest_return = true
    elsif ((not can_turn_in.call and is_bounty.call ['success', 'success_guard', 'success_heirloom']) or not can_do_bounty.call or not CharSettings[:enable_hunt_complete]) and percentmind >= CharSettings[:should_rest_mind].to_i
        rest_reason = 'mind is full'
        should_rest_return = true
    elsif not checkmana(CharSettings[:should_rest_mana].to_i)
        rest_reason = 'out of mana'
        should_rest_return = true
    elsif checkencumbrance(CharSettings[:should_rest_encum].to_i)
        rest_reason = 'encumbered'
        should_rest_return = true
    #elsif is_bounty.call ['success', 'success_heirloom', 'success_guard'] and $current_bounty == "bandits"
     #   rest_reason = 'Bandit task is done'
      #  should_rest_turn = true
    elsif $sbounty_rest
        if $sbounty_rest_reason
            rest_reason = $sbounty_rest_reason
        else
            rest_reason = '$sbounty_rest was set'
        end

        $sbounty_rest        = false
        $sbounty_rest_reason = nil

        should_rest_return = true
    else
        rest_reason = nil
        should_rest_return = false
    end
    sleep 0.5
    echo "Exiting should_rest with return value of: #{should_rest_return} and reason: #{rest_reason}" if $sbounty_debug
    should_rest_return
}

wander = proc { |boundaries|
	room = Room.current
	next_room_options = room.wayto.keys - boundaries
	next_room_options.delete_if { |room_id| (room.timeto[room_id].class == Proc) and room.timeto[room_id].call.nil? }
	next_room = next_room_options.find_all { |r| not $sbounty_wander_rooms.include?(r) }
	if next_room.empty?
		next_room = $sbounty_wander_rooms.find { |r| next_room_options.include?(r) }
	else
		next_room = next_room[rand(next_room.length)]
	end
	$sbounty_wander_rooms.delete(next_room)
	$sbounty_wander_rooms.push(next_room)
	way = room.wayto[next_room]
	if way.class == String
		move(way)
	else
		way.call
	end
}

go2 = proc { |room|
    fput 'symbol of return' if Room.current.title.to_s =~ /Maaghara/
    next if Room.current.id.to_s == room.to_s

    if checkarea =~ /table\]/i
        fput 'stand' until standing?
        move 'out'
    end

    wait_while { running? 'go2' }
    start_script('go2', [ room.to_s, '_disable_confirm_' ]);
    wait_while { running? 'go2' }
}

go2_nearest = proc { |list|
    room = Room[CharSettings[:rest_room]].find_nearest(list)
    if room.nil?
        error.call "failed to find nearest room"
    end

    go2.call(room)
}

go2_nearest_tag = proc { |tag|
    if checkarea =~ /table\]/i
        fput 'stand' until standing?
        fput 'out'
    end

    town = Room[CharSettings[:rest_room]].find_nearest_by_tag('town')
    room = Room[town].find_nearest_by_tag(tag)
    if room.nil?
        error.call "failed to find room by tag: #{tag}"
    end

    go2.call(room)
}

run_commands = proc { |commands|
    next if commands.empty?

    if commands.class != Array
        error.call "run_commands expects an input Array"
    end

    commands.each { |command| 
        if command =~ /^script\s+(.*?)(\s|$)(.*)/i
            script_name = $1
            script_args = $3
            if command =~ /\$/
                command_regex = /^script (\w+) (\S+)/.match(command)
                temp1 = eval("#{command_regex[2]}").to_s
                cmd_run_script(command_regex[1], temp1 )
            else
                cmd_run_script(script_name, script_args )
            end
        else 
            fput(command)
        end    
    }
}

run_scripts = proc { |scripts|
    scripts.each { |script|
        if script =~ /\$/
            script_regex = /(\w+) (\S+)/.match(script)
            args = eval("#{script_regex[2]}").to_s
            script = script_regex[1]
            cmd_run_script(script_regex[1], args )
        else        
            args   = script.split(' ')
            script = args.shift
            start_script(script, args, true)
            wait_while { running? script }
        end
    }
}


def cmd_run_script( name, args )
    if( args == nil || args =~ /^\s*$/ )
        run_script( name, true )
    else
        args = args.split(/ /)
        run_script( name, true, args )
    end
end


    def run_script( name, pause_bigshot = false, args = [] )
        if Script.running.find { |s| s.name.downcase == name.downcase }.paused or running? name
            stop_script name
            wait_while { running? name }
        end

        start_script name, args 
        if pause_bigshot
            wait_until { !running? name }
        end
    end

    def run_scripts( scripts, pause_bigshot = false )
        scripts.each do |i|
            tokens = i.split(/\s+/)
            if( tokens.size > 1 )
                run_script( tokens[0], pause_bigshot, tokens[1..-1] )
            else
                run_script( tokens[0], pause_bigshot )
            end
        end
    end


run_loot_script = proc {
    wait_while { running? CharSettings[:loot_script] }
    start_script(CharSettings[:loot_script], [], true)
    wait_while { running? CharSettings[:loot_script] }
}

hunt_prepare = proc {
    run_commands.call(CharSettings[:hunt_pre_commands])
}

rest_goto = proc {
    if checkarea =~ /table\]/i
        in_rest_area = true
    end
    next if in_rest_area

    if Spell[9825].known? && Map.current.image =~ /wl-graveyard/
        wait_while { running? 'go2' }
        start_script 'go2', [ '4141' ]
        wait_while { running?('go2') }
        fput "symbol of return"
    end

    go2.call(CharSettings[:rest_room])
}

rest_exit = proc {
    if checkarea =~ /table\]/i
        in_rest_area = true
    end
    next unless in_rest_area
    if Room.current.id != CharSettings[:rest_room] and Room.current.path_to(CharSettings[:rest_room]).nil?
        run_commands.call(CharSettings[:rest_out_commands])
    end
    in_rest_area = false
}

rest_enter = proc {
    if checkarea =~ /table\]/i
        in_rest_area = true
    end
    next if in_rest_area
    if Room.current.id != CharSettings[:rest_room] and Room.current.path_to(CharSettings[:rest_room]).nil?
        run_commands.call(CharSettings[:rest_in_commands])
    end
    in_rest_area = true
}

rest_run_scripts = proc {
    rest_exit.call
    run_scripts.call(CharSettings[:rest_scripts])
}

reload_hunter = proc {
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, get_bounty_location.call)
    $SBOUNTY_HUNTER_RELOAD.call
}

start_hunter = proc { |location|
    $SBOUNTY_HUNTER_SETUP.call(CharSettings.to_hash.dup, location)
    start_script($SBOUNTY_HUNTER_NAME, [], false)
}

finish_hunt = proc {
    if running? $SBOUNTY_HUNTER_NAME
        stop_script($SBOUNTY_HUNTER_NAME)
        wait_while { running? $SBOUNTY_HUNTER_NAME }
    end

    fput 'stance defensive' until checkstance('defensive') or checkstance('guarded')

    # pause to make sure looter isn't running
    wait_while { running? CharSettings[:loot_script] }

    # run loot script in case the hunter wasn't able to clean up
    if GameObj.npcs.find { |npc| npc.status =~ /dead/ } or is_bounty.call 'success_heirloom'
        run_loot_script.call
    end
}

remove_bounty = proc {
    next if (not CharSettings[:enable_expedite] and Spell['Next Bounty'].active? and stopbounty == false) or is_bounty.call 'none'

    rest_exit.call

    kill_script 'go2' if running? 'go2'

    go2_nearest_tag.call('advguild')

    print.call 'removing bounty, you have five seconds to kill me'
    sleep 5.00

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    ## A couple of bounties were being removed once they were completed.  Added error checking.
    if can_turn_in.call == false
    echo "is_bounty_call: #{is_bounty.call ['success', 'success_guard', 'success_heirloom']}" if $sbounty_debug
    fput 'bounty'
    sleep 1
    res = dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?want to be removed|Trying to sneak/
    if res =~ /Trying to sneak/
        fput "ask #{npc} about bounty"
    else
        dothistimeout "ask #{npc} about remove", 5, /^#{npc}.*?have removed you/
    end
    else 
        # Double check to make sure bounty is not ready for completion.
        echo "Error in bounty turn in. Please review!"
        echo "is_bounty_call: #{is_bounty.call ['success', 'success_guard', 'success_heirloom']}"
        fput 'bounty'
        sleep 1
        start_exec_script( <<-eos
            kill_script 'sbounty' if running? 'sbounty';
            kill_script 'bigshot' if running? 'bigshot';
            kill_script 'go2' if running? 'go2';
            sleep 2;
            start_script 'sbounty';
            eos
        )
        sleep 2
    end
    can_do_bounty_cache = nil
}

expedite_bounty = proc {
    print.call 'expediting bounty, you have five seconds to kill me'
    sleep 5.00

    remove_bounty.call

    rest_exit.call
    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    if npc.nil?
        error.call 'failed to find taskmaster'
    end

    res = dothistimeout "ask #{npc} about expedite", 5, /I'll expedite|You don't seem to have any expedited task reassignment|I still need to complete/
    if res =~ /expedited/
        expedite_left = false
    end

    can_do_bounty_cache = nil
}

get_bounty = proc {
    rest_exit.call

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask ##{npc.id} for bounty", 2, /(?:protective escort|creature problem|local gem dealer|local alchemist|local furrier|lost heirloom|local healer|local herbalist|local resident|bandit problem|I'm kind of busy right now)/

    if res.nil?
        error.call 'invalid response from taskmaster'
    elsif res =~ /Come back in about (\d+) minutes if you want another task./
        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = $1.to_i
    elsif res =~ /Come back in about/
        Spell['Next Bounty'].putup
        Spell['Next Bounty'].timeleft = 5
    elsif res =~ /bandit/
        remove_bounty.call
    end

    can_do_bounty_cache = nil
}

talk_to_herbalist = proc {
    go2_nearest.call([ 3824, 1851, 10396, 640, 5722, 2406, 11002, 9505 ])

    if Room.current.id == 10396
        npc = 'maraene'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /brother Barnstel|scarred Agarnil kris|healer|herbalist|merchant Kelph|famed baker Leaftoe|Akrash|old Mistress Lomara/i }
    end

    if is_bounty.call 'help_herbalist'
        res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
        if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
            print.call "received bounty from herbalist [#{$1} #{$2}]"
        end
    elsif bounty? =~ /#{bounty_patterns['task_forage']}/
        herb_name = $1.gsub(/s?$/,'')
        herbs     = lootsack.contents.find_all { |item| item.name =~ /#{herb_name}/ }

        if herbs.empty?
            error.call 'no herbs to turn in, why are you here?'
        end

        empty_hands
        herbs.each { |herb|
            fput "get ##{herb.id} from ##{lootsack.id}"
            result = dothistimeout "give ##{herb.id} to #{npc}", 3, /This looks perfect|That looks like it has been partially used up/

            if result !~ /perfect/
                fput "drop ##{herb.id}"
            end
        }
        fill_hands

        if (checkleft == herb_name and GameObj.left.type =~ /herb/) or (checkright == herb_name and GameObj.right_hand.type =~ /herb/)
            fput 'drop ' + herb_name
        end
    else
        error.call 'why are you at the herbalist?'
    end

    
    if bounty? =~ /#{$stop_bounty}/
      stopbounty = true
      remove_bounty.call
      start_exec_script("sleep 2;start_script('sbounty')")
      exit
    end
}

talk_to_gemdealer = proc {
    go2_nearest_tag.call('gemshop')

    if Room.current.id == 10327
        npc = 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|gem dealer|jeweler|Zirconia/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /interested in purchasing an? (.*?)\. .* go round up ([0-9]+) of them/
        name  = $1
        count = $2.to_i

        print.call "-- received bounty from gem dealer [#{count} #{name}]"
    end
}

talk_to_furrier = proc {
    go2_nearest_tag.call('furrier')

    if Room.current.id == 10327
        npc 'areacne'
    else
        npc = GameObj.npcs.find { |t| t.name =~ /dwarven clerk|furrier/i }
    end

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, I do have a task for you/
    if res =~ /I've recently received an order for ([0-9]+) (.*?)\./
        print.call "received bounty from furrier [#{$1} #{$2}]"
    end
}

get_guard_npc = proc {
    if Room.current.id == 10915
        'purser'
    else
        GameObj.npcs.find { |npc| npc.name =~ /guard|sergeant|guardsman|purser/i }
    end
}

find_guard = proc {
    go2_nearest_tag.call('advguard')
    npc = get_guard_npc.call

    if npc.nil?
        go2_nearest_tag.call('advguard2')
        npc = get_guard_npc.call
    end

    if npc.nil?
        error.call "failed to locate guard"
    end

    npc
}

talk_to_guard = proc {
    npc = find_guard.call

    res = dothistimeout "ask #{npc} about bounty", 5, /Yes, we do have a task for you|Ah, so you have returned/
    if res.nil?
        print.call "unknown response from guard: #{res}"
    end
}

get_random_location = proc {
    keys = []
    CharSettings[:locations].each { |key, data|
        if data[:enable_hunting_rotation]
            keys.push(key)
        end
    }
    name = keys[rand(keys.size)]

    if name.nil?
        error.call 'failed to find a hunting area'
    end

    [ name, CharSettings[:locations][name] ]
}

task_escort = proc { |target|
    print.call "escorting child to #{target}"

    path  = []
    step2 = proc { |destination_room|
        unless path and (s = path.index(Room.current.id)) and (d = path.index(destination_room)) and (s < d)
            previous, shortest_distances = Map.dijkstra(Room.current.id, destination_room)
            unless previous[destination_room]
                echo "error: failed to find a path between your current room (#{Room.current.id}) and destination room (#{destination_room})"
                exit
            end
            path = [ destination_room ]
            path.push(previous[path[-1]]) until previous[path[-1]].nil?
            path.reverse!
            previous = shortest_distances = nil
        end

        way = Room.current.wayto[path[path.index(Room.current.id)+1].to_s]

        if way.class == String
            move way
        elsif way.class == Proc
            way.call
        end
    }

    waitrt?
    fput 'stance defensive' unless checkstance('guarded')

    destination = Room[CharSettings[:rest_room]].find_nearest_by_tag(target)
    while Room.current.id != destination and is_bounty.call 'task_escort'
        if GameObj.npcs.find { |n| n.name =~ /child/i }
            step2.call(destination)
        end
        sleep 0.25
    end

    if is_bounty.call 'fail_child'
        print.call 'failed to escort child or child was killed'
    elsif npc = get_guard_npc.call
        print.call 'waiting for child to arrive'
        wait_until { GameObj.npcs.find { |n| n.name =~ /child/ } }

        if Room.current.id == 10915
            fput "ask purser for bounty"
        else
            fput "ask ##{npc.id} for bounty"
        end
    elsif target == 'advguard'
        task_escort.call 'advguard2'
    else
        error.call 'failed to find guard for escort'
    end
}

task_search = proc {
    if bounty? !~ /#{bounty_patterns['task_search']}/
        error.call 'you are not on a search bounty'
    end

    print.call 'searching for heirloom'

    name, location = get_bounty_location.call
    song_of_peace  = false
    invalid_rooms  = []
    last_room      = nil

    hunt_prepare.call
    rest_exit.call

    go2.call location[:room]

    while is_bounty.call 'task_search' and not CharSettings[:should_rest_wounded].call
        if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
            Spell[1011].cast
            song_of_peace = true
            fput 'stop 1012' if Spell[1012].active?
            fput 'stop 1009' if Spell[1012].active?
            GSC.bput "stow all", "^You put"
        end

        wander.call location[:boundaries]

        fput 'stand' until standing?
        fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

        if (GameObj.npcs.empty? or GameObj.npcs.nil?) and Room.current.location =~ /#{location[:location].downcase.strip}/i and not invalid_rooms.include? Room.current.id and Room.current.id != last_room
            run_commands.call CharSettings[:pre_search_commands]

            fput 'kneel' until kneeling?
            res = dothistimeout 'search', 1, /You intently search the area|You put your head to the ground and peer intently/
            if res =~ /You intently search the area|You put your head to the ground and peer intently/
                last_room = Room.current.id
            else
                print.call 'invalid room, skipping in the future'
                invalid_rooms.push Room.current.id
            end

            waitrt?

            run_commands.call CharSettings[:post_search_commands]

            while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.status !~ /dead/ }.nil?)
                fput 'stance offensive'
            end

            fput 'stand' until standing?

            fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

            if is_bounty.call 'task_found'
                run_loot_script.call
                break
            end
        end
    end

    waitrt?

    if Char.name == 'Iloru'
        GSC.run_wait_script('go2', 'town') 
        fput "stop 1011" if Spell[1011].active?
        GSC.run_wait_script('bardhunt', 'xx') 
    end
}

task_bandits = proc {
  error.call 'you are not on a bandits bounty' if bounty? !~ /#{bounty_patterns['task_bandit']}/
  print.call 'culling bandits'

  my_ambush = false
  $bandits = true
  ambush_room_count = XMLData.room_count

  location = $1.strip.downcase
  rooms_list = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
  attack_script = 'ubermonk'

  while not CharSettings[:should_rest_wounded].call
	  next_room = Room.current.find_nearest(rooms_list).to_i
	  rooms_list.delete(next_room)
    if next_room.nil? || Room.current.path_to(next_room).length > 1
      rooms_list = Room.list.find_all { |r| r.location =~ /#{location}/i }.collect { |r| r.id }
      next_room = Room.current.find_nearest(rooms_list).to_i
      rooms_list.delete(next_room)
    end
    waitrt?
    waitcastrt?

	  print.call 'moving to room ' + next_room.to_s

    fput 'stance defensive' unless checkstance == 'defensive'

    go2.call(next_room)
    sleep 1

    while not should_rest.call or not can_turn_in.call
      npcs = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status !~ /dead/ }
      dead = GameObj.npcs.to_a.find_all { |npc| npc.type =~ /bandit/ and npc.status =~ /dead/ }

      if npcs.empty?
        break
      else
        waitrt?
        waitcastrt?
        start_script "#{attack_script}"
        wait_while { running?(attack_script) }
      end
      sleep 0.1
      echo "Inside bandits attack loop" if $sbounty_debug
      echo "should_rest.call: #{should_rest.call} can_turn_in: #{can_turn_in.call}" if $sbounty_debug
    end

    echo "Outside bandits attack loop" if $sbounty_debug
    echo "should_rest.call: #{should_rest.call} can_turn_in: #{can_turn_in.call}" if $sbounty_debug

    break if should_rest.call or can_turn_in.call
    break if bounty? !~ /#{bounty_patterns['task_bandit']}/
    sleep 0.1
  end
  $bandits = false
}

task_forage = proc {
    echo bounty?
    if bounty? !~ /#{bounty_patterns['task_forage']}/
        error.call 'you are not on a forage bounty'
    end

    print.call 'foraging for herbs'

    herb     = $1.downcase
    location = $2
    count    = $3.to_i

    if bounty? =~ /#{$stop_bounty}/
        stopbounty = true
        remove_bounty.call
        start_exec_script("sleep 2;start_script('sbounty')")
        exit
    end

    refresh_spells = proc {
        [506, 603, 9704].each { |spell|
            if Spell[spell].known? and not Spell[spell].active? and Spell[spell].affordable?
                waitrt?
                waitcastrt?

                Spell[spell].cast
            end
        }

        yierka          = Spell['AA: Yierka']
        yierka_cooldown = Spell['AA: Yierka Cooldown']

        if yierka.known? and yierka.affordable? and not yierka_cooldown.active?
            yierka.cast
        end
    }

    get_herb_count = proc {
        lootsack.contents.find_all { |item| item.name =~ /#{herb.gsub(/s?$/,'')}/i }.size
    }

    last_forage_attempt = Time.now.to_i

    if not get_herb_count.call >= count
        hunt_prepare.call
        rest_exit.call

        rooms = get_herb_rooms.call(location, herb)

        cur_room  = 0
        num_tries = 0

        song_of_peace = false

        foragename = herb
 
        if foragename == 'twisted black mawflower' then foragename = 'mawflower'
            elsif foragename == 'stem of freesia flowers' then foragename = 'freesia flowers'
            elsif foragename == 'small green olive' then foragename = 'green olive'
            elsif foragename == 'mass of congealed slime' then foragename = 'congealed slime'
            elsif foragename == 'oozing fleshsore bulb' then foragename = 'fleshsore bulb'
            elsif foragename == 'rotting bile green fleshbulb' then foragename = 'fleshbulb'
            elsif foragename == 'discolored fleshbinder bud' then foragename = 'fleshbinder bud'
            elsif foragename == 'slime-covered grave blossom' then foragename = 'grave blossom'
            elsif foragename == "sprig of Imaera's Lace" then foragename = "Imaera's Lace"
            elsif foragename == 'handful of elderberries' then foragename = 'elderberries'
            elsif foragename == 'sprig of wild lilac' then foragename = 'lilac'
            elsif foragename == 'fragrant white lily' then foragename = 'white lily'
            elsif foragename == 'handful of huckleberries' then foragename = 'huckleberries'
            elsif foragename == 'trollfear mushroom' then foragename = 'mushroom'
            elsif foragename == 'bunch of wild grapes' then foragename = 'wild grapes'
            elsif foragename == 'handful of blueberries' then foragename = 'blueberries'
            elsif foragename == 'handful of raspberries' then foragename = 'raspberries'
            elsif foragename == 'layer of onion skin' then foragename = 'onion skin'
            elsif foragename == 'vermilion fire lily' then foragename = 'fire lily'
            elsif foragename == 'handful of walnuts' then foragename = 'walnuts'
            elsif foragename == 'orange tiger lily' then foragename = 'tiger lily'
            elsif foragename == 'small branch of acacia' then foragename = 'branch of acacia'
            elsif foragename == 'golden flaeshorn berry' then foragename = 'flaeshorn berry'
            elsif foragename == 'white alligator lily' then foragename = 'alligator lily'
            elsif foragename == 'white spider lily' then foragename = 'spider lily'
            elsif foragename =~ /(silver|bright blue|fiery red|snow white|pale violet|peach|soft orange|pink|yellow|lavender|ice blue|azure|bright red|pale green|soft yellow|bright green|light red) iceblossom/ then foragename = 'iceblossom'
            elsif foragename =~ /(bent|short|heavy) stick/ then foragename = 'stick'
            elsif foragename =~ /(blue|red|green|pink|purple|yellow|white) mold/ then foragename = 'mold'
            elsif foragename == 'handful of snowberries' then foragename = 'snowberries'
            elsif foragename == 'sprig of edelweiss' then foragename = 'edelweiss'
            elsif foragename == 'handful of bearberries' then foragename = 'bearberries'
            elsif foragename == 'cluster of woad leaves' then foragename = 'woad leaves'
            elsif foragename == 'large black toadstool' then foragename = 'black toadstool'
            elsif foragename == 'some glowing green lichen' then foragename = 'green lichen'
            elsif foragename == 'luminescent green fungus' then foragename = 'green fungus'
            elsif foragename == 'black-tipped wyrm thorn' then foragename = 'wyrm thorn'
            elsif foragename == 'some fetid black slime' then foragename = 'black slime'
            elsif foragename == 'sprig of sky-blue delphinuris' then foragename = 'delphinuris'
            elsif foragename == 'handful of mustard seeds' then foragename = 'mustard seeds'
            elsif foragename == 'handful of snowberries' then foragename = 'snowberries'
            elsif foragename == 'sprig of wild phlox' then foragename = 'phlox'
            elsif foragename == 'cluster of gorse' then foragename = 'gorse'
            elsif foragename == 'giant glowing toadstool' then foragename = 'glowing toadstool'
        end

        while not get_herb_count.call >= count and not CharSettings[:should_rest_wounded].call and num_tries < 3
            go2.call(rooms[cur_room])
            cur_room = cur_room + 1

            if cur_room >= rooms.length
                cur_room  = 0
                num_tries = num_tries + 1
            end

            while not get_herb_count.call >= count and not CharSettings[:should_rest_wounded].call
                if Spell[1011].known? and Spell[1011].affordable? and not song_of_peace
                    Spell[1011].cast
                    song_of_peace = true
                    fput 'stop 1007'
                    fput 'stop 1012'
                end

                waitrt?
                fput 'stance defensive' unless checkstance == 'defensive'

                refresh_spells.call

                if not song_of_peace and not GameObj.npcs.find_all { |npc| npc.status !~ /dead|gone/ }.nil?
                    break
                end

                if not kneeling?
                    run_commands.call(CharSettings[:pre_search_commands])
                    fput "kneel" until kneeling?

                    if Spell[213].known? and Spell[213].affordable?
                        fput "incant 213"
                    end

                    if Spell[205].known? and Spell[205].affordable?
                        fput "incant 205"
                    end
                end

                res = dothistimeout "forage #{foragename}", 1, /could even thrive|not even positive|it could be|it could even be found|and manage to find|Roundtime|In order to forage|foraging here recently/
                echo res
			    if res =~ /it could be|it could even be found|not even positive|could even thrive/
                    rooms.delete(cur_room)
				    break
			    elsif res =~ /and manage to find/
                    echo checkleft
                    echo foragename
				    GSC.bput "stow left", "You put" if checkleft
			        GSC.bput "stow right", "You put" if checkright

				    print.call "-- success, found #{get_herb_count.call} of #{count} #{herb}"
			    elsif res =~ /In order to forage/
				    fput "stow all"
			    elsif res =~ /foraging here recently/
                    rooms.delete(cur_room)
				    break
			    else
			        print.call "-- failure, found #{get_herb_count.call} of #{count} #{herb}"
			    end
            end

            GSC.bput "stow left", "You put" if checkleft
            GSC.bput "stow right", "You put" if checkright

            if not standing?
                run_commands.call(CharSettings[:post_search_commands])

                while not checkstance 'offensive' and (song_of_peace or GameObj.npcs.find_all { |npc| npc.status !~ /dead/ }.nil?)
                    fput 'stance offensive'
                end

                fput 'stance defensive' until checkstance 'defensive' or checkstance 'guarded'

                fput "stand" until standing?
            end
        end
    end

    if song_of_peace
        fput "stop 1011"
    end

    if get_herb_count.call >= count
        talk_to_herbalist.call
        last_forage_attempt = 0
    end
}

success_heirloom = proc {
    print.call 'turning in heirloom'

    npc = find_guard.call

    empty_hands

    close = false
    if lootsack.contents.nil?
        open_result = dothistimeout "open ##{lootsack.id}", 5, /^You open|^That is already open\.$/
        if open_result =~ /^You open/
            close = true
        else
            dothistimeout "look in ##{lootsack.id}", 5, /In .*? you see/
        end
    end

    found = false
    lootsack.contents.each { |item|
        res = dothistimeout "look ##{item.id}", 2, /^Engraved .* initials|^You see nothing unusual\.$|^The ring appears|^It takes you a moment|^It is difficult to see/
        if res =~ /^Engraved .* initials/
            fput "get ##{item.id}"
            fput "give ##{item.id} to #{npc}"
            found = true

            break
        end
    }

    fput "close ##{lootsack.id}" if close

    if not found
        error.call 'failed to find heirloom for guard'
    end

    fill_hands
}

turn_in = proc {
    rest_exit.call

    if is_bounty.call 'success_guard'
        talk_to_guard.call
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    go2_nearest_tag.call('advguild')

    npc = GameObj.npcs.find { |t| t.name =~ /taskmaster/i }
    res = dothistimeout "ask #{npc} about bounty", 5, /^#{npc}.*?done with that assignment/
    10.times {
        if line = get? and line =~ /You have earned ([0-9]+) bounty points?, ([0-9]+) experience points, and ([0-9]+) silver\./
            print.call "finished task (#{$1} points, #{$2} exp, #{$3} silver)"
            break
            sleep 1
            sleep 76 if checkrt > 0
        end

        sleep 0.1
    }

    run_loot_script.call

    can_do_bounty_cache = nil
}

talk_to_npc = proc {
    if is_bounty.call ['help_creature', 'help_resident', 'help_heirloom', 'success_guard']
        talk_to_guard.call
    # separate bandits so we don't trigger them on accident while walking
    elsif is_bounty.call ['help_bandit'] and CharSettings[:enable_bandit]
        talk_to_guard.call
    elsif is_bounty.call 'help_furrier'
        talk_to_furrier.call
    elsif is_bounty.call 'help_herbalist'
        talk_to_herbalist.call
    elsif is_bounty.call 'help_gemdealer'
        talk_to_gemdealer.call
    end
}

help = proc {
    respond
    respond 'SpiffyBounty by SpiffyJr (theman@spiffyjr.me)'
    respond 'usage: ;sbounty [hunter=bigshot]'
    respond
}

hunter = 'sbounty-bigshot'

if script.vars[1] =~ /^setup$/i
    setup.call
    exit
elsif script.vars[1] =~ /^help$/i
    help.call
    exit
elsif script.vars[1] =~ /^forage$/i
    task_forage.call
    exit
elsif script.vars[1] =~ /^npc$/i
    talk_to_npc.call
    exit
elsif script.vars[1]
    hunter = "sbounty-#{script.vars[1]}"
end

task_accepted = false
resting       = false

start_script(hunter, nil, true)
wait_while { running? hunter }

if not defined? $SBOUNTY_HUNTER_SETUP
    error.call 'hunter setup was not defined'
elsif not defined? $SBOUNTY_HUNTER_NAME
    error.call 'hunter name was not defined'
elsif not defined? $SBOUNTY_HUNTER_RELOAD
    error.call 'hunter reload was not defined'
end

before_dying { kill_script $SBOUNTY_HUNTER_NAME if running? $SBOUNTY_HUNTER_NAME }

while true
    if bounty? =~ /#{$stop_bounty}/
      stopbounty = true
      remove_bounty.call
      start_exec_script("sleep 2;start_script('sbounty')")
      exit
    end

    echo "start of total loop" if $sbounty_debug
    talk_to_npc.call

    if can_do_bounty.call and not CharSettings[:should_rest_wounded].call
        if is_bounty.call 'task_search'
            task_search.call
        elsif is_bounty.call 'task_forage' and Time.now.to_i >= last_forage_attempt + last_forage_delay
            task_forage.call
        end
    elsif Spell['Next Bounty'].active? and (expedite_left and not is_bounty.call 'none' and not can_do_bounty.call and CharSettings[:enable_expedite])
        expedite_bounty.call
        next
    end

    if is_bounty.call 'task_escort' and GameObj.npcs.find { |npc| npc.name =~ /child/ }
        task_escort.call 'advguard'
    elsif is_bounty.call 'task_fail'
        can_do_bounty_cache = nil
    elsif is_bounty.call 'success_heirloom'
        success_heirloom.call
    end

    exit if dead?

    if can_turn_in.call
        turn_in.call
        resting = false
    else
        echo "total loop: in hunting check" if $sbounty_debug
        echo "should_hunt_call: #{should_hunt.call} should_rest.call: #{should_rest.call}" if $sbounty_debug
        echo "can_do_bounty: #{can_do_bounty.call}" if $sbounty_debug
        if not can_do_bounty.call and not Spell['Next Bounty'].active?
            remove_bounty.call
            get_bounty.call
        elsif should_hunt.call and not should_rest.call and not has_skins.call
            resting  = false
            provoked = false
            success  = false
            bounty   = bounty?

            rest_exit.call
            hunt_prepare.call

            # default hunter location
            if can_do_bounty.call
                # order is important here - bandits and regular culling look similar
                if is_bounty.call ['task_bandit']
                    task_bandits.call
                elsif is_bounty.call ['task_cull', 'task_dangerous', 'task_heirloom', 'task_rescue', 'task_skin']
                    start_hunter.call(get_bounty_location.call)
                else
                    start_hunter.call(get_random_location.call)
                end
            else
                start_hunter.call(get_random_location.call)
            echo "Exiting can_do_bounty.call" if $sbounty_debug
            echo "Is_bounty.call value: #{is_bounty.call}" if $sbounty_debug
            end

            while not should_rest.call and running? $SBOUNTY_HUNTER_NAME
                if bounty? =~ /#{bounty_patterns['task_provoked']}/ and not provoked
                    reload_hunter.call
                    provoked = true
                elsif is_bounty.call 'task_escort'
                    break
                elsif has_skins.call
                    break
                elsif not success and (bounty? != bounty and (is_bounty.call [ 'success', 'success_heirloom' ] or (provoked and is_bounty.call 'success_guard')))
                    finish_hunt.call
                    start_hunter.call(get_random_location.call)

                    success = true
                elsif can_turn_in.call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                end

                sleep 0.10
            end
            echo "Exiting while not should_rest.call and running? $SBOUNTY_HUNTER_NAME LOOP." if $sbounty_debug

            finish_hunt.call
        elsif not can_turn_in.call
            rest_goto.call

            if not resting or CharSettings[:should_rest_wounded].call
                rest_run_scripts.call
                rest_goto.call

                sleep 1
            end

            rest_enter.call

            while not should_hunt.call or should_rest.call
                echo "Inside rest loop." if $sbounty_debug
                if can_turn_in.call
                    break
                elsif CharSettings[:should_rest_wounded].call
                    break
                elsif not can_do_bounty.call and not Spell['Next Bounty'].active?
                    break
                elsif (can_do_bounty.call or is_bounty.call ['success', 'success_guard', 'success_heirloom']) and should_hunt.call
                    break
                end

                fput 'exp'
                dothistimeout 'hide', 2, /^Roundtime/ if !hidden? and Char.name == 'Kalros'
                waitrt?

                if rest_reason.nil?
                    rest_reason = hunt_reason
                end
                print.call "still resting because: #{rest_reason}"

                sleep CharSettings[:rest_sleep_interval]
            end

            resting = true
            rest_exit.call
        end
    end

    sleep 0.10
end
